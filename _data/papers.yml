rumsevicius23sinatra:
  title:
    plain:  "Sinatra: Stateful Instantaneous Updates for Commercial Browsers through Multi-Version eXecution"
  projects:
    - mvxhll
  authors:
    - urumsevicius
    - svenkateshwaran
    - ekidane
    - me
  publication:
    type:      conference
    publisher: "Schloss Dagstuhl – Leibniz-Zentrum für Informatik"
    nth:    "37th"
    title:
      full:    "European Conference on Object-Oriented Programming"
      short:   "ECOOP"
    location:  "Seattle, WA, USA"
    date:      "July, 2023"
  artifact: https://doi.org/10.5281/zenodo.7647070
  github: bitslab/sinatra
  downloads:
    pdf:    rumsevicius23sinatra.pdf
    slides: rumsevicius23sinatra-talk.pdf
    youtube: JdrCeb-_1Hg
  abstract: "Browsers are the main way in which most users experience the internet, which makes them a prime target for malicious entities. The best defense for the common user is to keep their browser always up-to-date, installing updates as soon as they are available. Unfortunately, updating a browser is disruptive as it results in loss of user state. Even though modern browsers reopen all pages (tabs) after an update to minimize inconvenience, this approach still loses all local user state in each page (e.g., contents of unsubmitted forms, including associated JavaScript validation state) and assumes that pages can be refreshed and result in the same contents. We believe this is an important barrier that keeps users from updating their browsers as frequently as possible.


In this paper, we present the design, implementation, and evaluation of SINATRA, which supports instantaneous browser updates that do not result in any data loss through a novel Multi-Version eXecution (MVX) approach for JavaScript programs. SINATRA works in pure JavaScript, does not require any browser support, thus works on closed-source browsers, and requires trivial changes to each target page, that can be automated. First, SINATRA captures all the non-determinism available to a JavaScript program (e.g., event handlers executed, expired timers, invocations of Math.random). Our evaluation shows that SINATRA requires 6MB to store such events, and the memory grows at a modest rate of 256KB/s as the user keeps interacting with each page. When an update becomes available, SINATRA transfer the state by re-executing the same set of non-deterministic events on the new browser. During this time, which can be as long as 1.5 seconds, SINATRA uses MVX to allow the user to keep interacting with the old browser. Finally, SINATRA changes the roles in less than 10ms, and the user starts interacting with the new browser, effectively performing a browser update with zero downtime and no loss of state."
arvan22emnlp:
  title:
    plain:  "Reproducibility in Computational Linguistics: Is Source Code Enough?"
  projects:
    - nlprepro
  authors:
    - marvan
    - me
    - nparde
  publication:
    type:      conference
    publisher: Association for Computational Linguistics
    nth:    "2022"
    title:
      full:    "Empirical Methods in Natural Language Processing"
      short:   "EMNLP"
    location:  "Abu Dhabi, United Arab Emirates"
    date:      "December, 2022"
  downloads:
    pdf:    arvan22emnlp.pdf
    artifact: https://zenodo.org/record/6728628
  abstract: "The availability of source code has been put forward as one of the most critical factors for improving the reproducibility of scientific research. This work studies trends in source code availability at major computational linguistics conferences, namely, ACL, EMNLP, LREC, NAACL, and COLING. We observe positive trends, especially in conferences that actively promote reproducibility. We follow this by conducting a reproducibility study of eight papers published in EMNLP 2021, finding that source code releases leave much to be desired. Moving forward, we suggest all conferences require self-contained artifacts and provide a venue to evaluate such artifacts at the time of publication. Authors can include small-scale experiments and explicit scripts to generate each result to improve the reproducibility of their work."
kukucka22confetti:
  title:
    plain:  "CONFETTI: Amplifying Concolic Guidance for Fuzzers"
  projects: 
    - fuzzprops
  authors:
    - jkukucka
    - me
    - pammann
    - jbell
  publication:
    type:      conference
    publisher: "IEEE"
    nth:    "44th"
    title:
      full:    "International Conference on Software Engineering"
      short:   "ICSE"
    location:  "Pittsburgh, PA, USA"
    date:      "May, 2022"
  github: neu-se/confetti
  downloads:
    pdf:    kukucka22confetti.pdf
    slides: kukucka22confettislides.pdf
    poster: kukucka22confettiposter.pdf
    youtube: -R9WuOUs8I8
  abstract: "Fuzz testing (fuzzing) allows developers to detect bugs and vulnerabilities in code by automatically generating defect-revealing inputs. Most fuzzers operate by generating inputs for applications and mutating the bytes of those inputs, guiding the fuzzing process with branch coverage feedback via instrumentation. Whitebox guidance (e.g., taint tracking or concolic execution) is sometimes integrated with coverage-guided fuzzing to help cover tricky-to-reach branches that are guarded by complex conditions (so-called “magic values”). This integration typically takes the form of a targeted input mutation, eg placing particular byte values at a specific offset of some input in order to cover a branch. However, these dynamic analysis techniques are not perfect in practice, which can result in the loss of important relationships between input bytes and branch predicates, thus reducing the effective power of the technique. We introduce a new, surprisingly simple, but effective technique, global hinting, which allows the fuzzer to insert these interesting bytes not only at a targeted position, but in any position of any input. We implemented this idea in Java, creating CONFETTI, which uses both targeted and global hints for fuzzing. In an empirical comparison with two baseline approaches, a state-of-the-art greybox Java fuzzer and a version of CONFETTI without global hinting, we found that CONFETTI covers more branches and finds 15 previously unreported bugs, including 9 that neither baseline could find. By conducting a forensic analysis of CONFETTI’s execution, we determined that global hinting was at least as effective at revealing new coverage as traditional, targeted hinting."
arras22sabre:
  title:
    plain:  "SaBRe: load-time selective binary rewriting"
  projects: varan
  authors:
    - parras
    - aandronidis
    - me
    - kmituzas
    - qshu
    - dgrumberg
    - ccadar
  publication:
    type:      journal
    publisher: "Springer-Verlag"
    title:
      full:    "International Journal on Software Tools for Technology Transfer"
      short:   "IJSTTT"
    date:      "April, 2022"
    accepted:  "December, 2021"
    published: "January, 2022"
    pages:     [205,223]
    volume: 24
    nth: 2
  github: srg-imperial/SaBRe
  downloads:
    pdf:    arras22sabre.pdf
  abstract: "Binary rewriting consists in disassembling a program to modify its instructions. However, existing solutions suffer from shortcomings in terms of soundness and performance. We present SaBRe, a load-time system for selective binary rewriting. SaBRe rewrites specific constructs—particularly system calls and functions—when the program is loaded into memory, and intercepts them using plugins through a simple API. We also discuss the theoretical underpinnings of disassembling and rewriting. We developed two backends—for x86_64 and RISC-V—which were used to implement three plugins: a fast system call tracer, a multi-version executor, and a fault injector. Our evaluation shows that SaBRe imposes little overhead, typically below 3%."
pina19mvedsua:
  title:
    plain:  "MVEDSUa: Higher Availability Dynamic Software Updates via Multi-Version Execution"
  projects:
  authors:
    - me
    - aandronidis
    - mwh
    - ccadar
  publication:
    type:      conference
    publisher: "ACM"
    nth:    "24th"
    title:
      full:    "Architectural Support for Programming Languages and Operating Systems"
      short:   "ASPLOS"
    location:  "Providence, RI, USA"
    date:      "April, 2019"
  downloads:
    pdf:    pina19mvedsua.pdf
    slides: pina19mvedsuaslides.pdf
    poster: pina19mvedsuaposter.pdf
    youtube: PfmKkltLK4Y
  abstract: "Dynamic Software Updating (DSU) is a general-purpose technique for patching stateful software without shutting it down, which enables both timely updates and non-stop service.
  However, applying an update could induce a long delay in service, and bugs in the update - both in the changed code and in the specification for effecting that change dynamically - may cause the updated software to crash or misbehave.

This paper proposes MVEDSUa, a system that solves these problems by augmenting a DSU system with support for Multi-Version Execution (MVE).
To start, MVEDSUa performs an update in parallel with the original system, thereby avoiding any service
delay.
Then, it monitors that the updated and original systems' responses agree when given the same inputs.
Expected differences are specified by the programmer, so remaining differences signal likely errors.
If the new version shows no problems, it can be installed permanently.

We implemented MVEDSUa on top of Kitsune and Varan state-of-the-art DSU and MVE systems respectively, and used it to update several high-performance servers: Redis, Memcached, and VSFTPD.
Our results show that MVEDSUa significantly reduces the update-time delay, imposes little overhead in steady state, and easily recovers from a variety of update-related errors.
    "
bellpina18crochet:
  title:
    plain:  "CROCHET: Checkpoint and Rollback via Lightweight Heap Traversal on Stock JVMs"
  projects:
  authors:
    - jbell
    - me
  publication:
    type:      conference
    publisher: "Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik"
    nth:    "32nd"
    nopub:     True
    title:
      full:    "European Conference on Object-Oriented Programming"
      short:   "ECOOP"
    location:  "Amsterdam, Netherlands"
    date:      "July, 2018"
  github: gmu-swe/crochet
  downloads:
    pdf:    bellpina18crochet.pdf
    slides: bellpina18crochetslides.pdf
    poster: bellpina18crochetposter.pdf
  abstract: "
    Checkpoint/rollback (CR) mechanisms create snapshots of the state of a
    running application, allowing it to later be restored to that checkpointed
    snapshot. Support for checkpoint/rollback enables many program analyses and
    software engineering techniques, including test generation, fault tolerance,
    and speculative execution.

    Fully automatic CR support is built into some modern operating systems.
    However, such systems perform checkpoints at the coarse granularity of whole
    pages of virtual memory, which imposes relatively high overhead to
    incrementally capture the changing state of a process, and makes it
    difficult for applications to checkpoint only some logical portions of their
    state. CR systems implemented at the application level and with a finer
    granularity typically require complex developer support to identify: (1)
    where checkpoints can take place, and (2) which program state needs to be
    copied. A popular compromise is to implement CR support in managed runtime
    environments, e.g., the Java Virtual Machine (JVM), but this typically
    requires specialized, non-standard runtime environments, limiting
    portability and adoption of this approach.

    In this paper, we present a novel approach for Checkpoint ROllbaCk via
    lightweight HEap Traversal (Crochet), which enables fully automatic
    fine-grained lightweight checkpoints within unmodified commodity JVMs
    (specifically Oracle’s HotSpot and OpenJDK). Leveraging key insights about
    the internal design common to modern JVMs, Crochet works entirely through
    bytecode rewriting and standard debug APIs, utilizing special proxy objects
    to perform a lazy heap traversal that starts at the root references and
    traverses the heap as objects are accessed, copying or restoring state as
    needed and removing each proxy immediately after it is used. We evaluated
    Crochet on the DaCapo benchmark suite, finding it to have very low runtime
    overhead in steady state (ranging from no overhead to 1.29x slowdown), and
    that it often outperforms a state-of-the-art system-level checkpoint tool
    when creating large checkpoints.
    "
pina18freeda:
  title:
    plain:  "FreeDA: Deploying Incompatible Stock Dynamic Analyses in Production via Multi-Version Execution"
  projects:
    - "varan"
  authors:
    - me
    - aandronidis
    - ccadar
  publication:
    type:      conference
    publisher: "ACM"
    prenth:   "2018"
    title:
      full:    "International Conference on Computing Frontiers"
      short:   "CF"
    location:  "Ischia, Italy"
    date:      "May, 2018"
  downloads:
    pdf:    pina18freeda.pdf
  abstract: "
    Dynamic analyses such as those implemented by compiler sanitizers and
    Valgrind are effective at finding and diagnosing challenging bugs and
    security vulnerabilities.  However, most analyses cannot be combined
    on the same program execution, and they incur a high overhead, which
    typically prevents them from being used in production.

    This paper addresses the ambitious goal of running concurrently
    multiple incompatible stock dynamic analysis tools in production,
    without requiring any modifications to the tools themselves or adding
    significant runtime overhead to the deployed system.  This is
    accomplished using multi-version execution, in which the dynamic
    analyses are run concurrently with the native version, all on the same
    program execution.

    We implement our approach in a system called FreeDA and show that it
    is applicable to several common scenarios, involving network servers
    and interactive applications.  In particular, we show how incompatible
    stock dynamic analyses implemented by Clang's sanitizers and Valgrind
    can be used to check high-performance servers such as Memcached, Nginx
    and Redis, and interactive applications such as Git, HTop and OpenSSH.
    "
pina17varandsl:
  title:
    plain:  "A DSL Approach to Reconcile Equivalent Divergent Program Executions"
  projects:
    - "varan"
  authors:
    - me
    - dgrumberg
    - aandronidis
    - ccadar
  publication:
    type:      conference
    publisher: "USENIX"
    prenth:    "2017"
    title:
      full:    "Annual Technical Conference"
      short:   "USENIX ATC"
    location:  "Santa Clara, CA, USA"
    date:      "July, 2017"
  downloads:
    pdf:    pina17varandsl.pdf
    slides: pina17varandslslides.pdf
  abstract: "
    Multi-Version Execution (MVE) deploys multiple versions of the same
    program, typically synchronizing their execution at the level of system
    calls. By default, MVE requires all deployed versions to issue the same
    sequence of system calls, which limits the types of versions which can be
    deployed.

    In this paper, we propose a Domain-Specific Language (DSL) to reconcile
    expected divergences between different program versions deployed through MVE.
    We evaluate the DSL by adding it to an existing MVE system (Varan) and testing
    it via three scenarios: (1) deploying the same program under different
    configurations, (2) deploying different releases of the same program, and (3)
    deploying dynamic analyses in parallel with the native execution. We also
    present an algorithm to automatically extract DSL rules from pairs of system
    call traces.  Our results show that each scenario requires a small number of
    simple rules (at most 14 rules in each case) and that writing DSL rules can be
    partially automated.
    "
pina16tedsuto:
  title:
    plain:  "Tedsuto: A General Framework for Testing Dynamic Software Updates"
  projects:
    - "rubah"
  authors:
    - me
    - mwh
  publication:
    type:      conference
    publisher: "IEEE"
    nth:       "8th"
    title:
      full:    "International Conference on Software Testing, Verification and Validation"
      short:   "ICST"
    location:  "Chicago, IL, USA"
    date:      "April, 2016"
  downloads:
    pdf:    pina16tedsuto.pdf
    slides: pina16slides.pdf
  abstract: "
    Dynamic software updating (DSU) is a technique for patching running
    programs, to fix bugs or add new features.  This paper presents Tedsuto, a
    general testing framework for DSU, along with a concrete implementation of
    it for Rubah, a state-of-the-art Java-based DSU system. Tedsuto uses
    system-level tests developed for the old and new versions of the updateable
    software, and systematically tests whether a dynamic update might result in
    a test failure. Very often this process is fully automated, while in some
    cases (e.g., to test new-version functionality) some manual annotations are
    required.  To evaluate Tedsuto's efficacy, we applied it to dynamic updates
    previously developed (and tested in an ad hoc manner) for the H2 SQL
    database server and the CrossFTP server--- two real-world, multithreaded
    systems.  We used three large test suites, totalling 446 tests, and we found
    a variety of update-related bugs quickly, and at low cost.
    "
pina16phd:
  title: 
    plain:  "Practical Dynamic Software Updating"
  projects:
    - "rubah"
    - "dustm"
  authors:
    - me
  publication:
    type:  phdthesis
    date: "February, 2016"
    school:
      plain:  "Instituto Superior Técnico, University of Lisbon"
      bibtex: "Instituto Superior T\\'{\\e}cnico, University of Lisbon"
    location: "Lisbon, Portugal"
  downloads:
    pdf:    pina16phd.pdf
    slides: pina16phdslides.pdf
  abstract: "
    Updating a program is unavoidable to fix bugs, add features, or improve
    performance. This is, however, a disruptive operation that involves stopping and
    restarting the running program, with the side-effect of service downtime and
    data loss. The ability to update a program without stopping it — to perform a
    Dynamic Software Update — is thus increasingly important in a world where
    service downtime and data loss map directly to loss of revenue.

    
    There are, of course, highly-available systems that simply cannot stop and
    already support dynamic updates. These systems, however, rely on redundant
    hardware, already present for fault tolerance, to incrementally update some
    machines while others keep providing the service. These approaches employ
    complex and domain-specific algorithms that restrict the flexibility of updates.
    The research community has focused on this problem and produced a vast body of
    work. However, to date, there is no practical solution for dynamic software
    updating.

    
    In this work, I propose the first practical solution for Dynamic Software
    Updating for languages that run in a managed environment, in particular, Java.
    The approach I propose supports unrestricted changes between successive program
    versions and does not limit the updatable program from using any language or
    runtime feature. Moreover, it does not add any steady-state overhead and
    requires only a short pause in program execution to perform an update (that is
    not proportional to the size of the program state).

    
    I propose updates to be supported explicitly as program features. Therefore, the
    developer needs to change their application to support updating it. The solution
    I propose minimizes the required manual changes and automates most of the code
    that describes each update. Furthermore, given that the developer may
    inadvertently introduce errors, only visible during the update process, the
    approach I propose provides a way for the developer to re-use existing system
    tests, and write new ones, that ensure that the updated program behaves as
    expected after an update.
    "
pina15varan:
  title:
    plain:  "Towards Deployment-Time Dynamic Analysis of Server Applications"
  projects:
    - "varan"
  authors:
    - me
    - ccadar
  publication:
    type: workshop
    publisher: "ACM"
    nth:       "13th"
    title:
      full:    "International Workshop on Dynamic Analysis"
      short:   "WODA"
    location:  "Pittsburgh, PA, USA"
    date:     "October, 2015"
    notes: "Extended abstract"
  downloads:
    pdf:    pina15varan.pdf
    slides: pina15slides.pdf
  abstract: "
    Bug-finding tools based on dynamic analysis (DA), such as Valgrind or the
    compiler sanitizers provided by Clang and GCC, have become ubiquitous during
    software development. These analyses are precise but incur a large performance
    overhead (often several times slower than native execution), which makes them
    prohibitively expensive to use in production. In this work, we investigate the
    exciting possibility of deploying such dynamic analyses in production code,
    using a multi-version execution approach.
    "
pina14oopsla:
  title:
    plain:  "Rubah: DSU for Java on a Stock JVM"
    bibtex: "Rubah: {DSU} for Java on a Stock {JVM}"
  projects:
    - "rubah"
  authors:
    - me
    - lveiga
    - mwh
  publication:
    type: conference
    publisher: "ACM"
    nth:       "2014"
    title:
      full:    "International Conference on Object-Oriented Programming Languages, Systems, and Applications"
      short:   "OOPSLA"
    location:  "Portland, OR, USA"
    date:     "October, 2014"
  downloads:
    pdf:    pina14oopsla.pdf
    slides: pina14oopslaslides.pdf
  abstract: "
    This paper presents Rubah, the first dynamic software updating system for Java
    that: is portable, implemented via libraries and bytecode rewriting on top of a
    standard JVM; is efficient, imposing essentially no overhead on normal,
    steady-state execution; is flexible, allowing nearly arbitrary changes to
    classes between updates; and is non-disruptive employing either a novel eager
    algorithm that transforms the program state with multiple threads, or a novel
    lazy algorithm that transforms objects as they are demanded, post-update.
    Requiring little programmer effort, Rubah has been used to dynamically update
    five long-running applications: the H2 database, the Voldemort key-value store,
    the Jake2 implementation of the Quake 2 shooter game, the CrossFTP server, and
    the JavaEmailServer.
    "
pina13hotswup:
  title:
    plain:  "Rubah: Efficient, General-purpose Dynamic Software Updating for Java"
  projects:
    - "rubah"
  authors:
    - me
    - mwh
  publication:
    type: workshop
    publisher: "USENIX"
    nth:       "5th"
    title:
      full:    "International Workshop on Hot Topics in Software Upgrades"
      short:   "HotSWUp"
    location:  "San Jose, CA, USA"
    date:     "June, 2013"
  downloads:
    pdf:    pina13hotswup.pdf
    slides: pina13hotswupslides.pdf
  abstract: "
      This paper presents Rubah, a new dynamic software updating (DSU) system
      for Java programs that works on stock VMs. Rubah supports a large range of
      program changes (e.g., changes to the class hierarchy and updates to running
      methods), does not restrict important programming idioms (e.g., reflection),
      and, as shown by performance experiments using an updatable version of the H2
      database management system, imposes low overhead on normal execution.
      "
pina12hotswup:
  title:
    plain: "Atomic Dynamic Upgrades Using Software Transactional Memory"
  projects:
    - "dustm"
  authors:
    - me
    - jcachopo
  publication:
    type: workshop
    publisher: "IEEE"
    nth:       "4th"
    title:
      full:    "International Workshop on Hot Topics in Software Upgrades"
      short:   "HotSWUp"
    location:  "Zurich, Switzerland"
    date:      "June, 2012"
  downloads:
    pdf:    pina12hotswup.pdf
    slides: pina12hotswupslides.pdf
  abstract: "
      In this paper, we propose the use of a Software Transactional Memory to
      implement a Dynamic Software Upgrade system that combines two desirable
      properties.  First, it provides a simple semantics to the developer, while
      allowing upgrades to occur atomically, concurrently with the execution of the
      program.  Second, it converts the program’s data lazily, as data is
      progressively accessed by the execution of the upgraded program.  We present
      also experimental results that show that our lazy approach to software upgrades
      is able to upgrade a system without affecting significantly the maximum response
      time of the system’s operations, whereas an immediate approach shows values of
      maximum response time up to three orders of magnitude higher.
      "
pina11tmc:
  title: 
    plain:  "Profiling and tuning the performance of an STM-based concurrent program"
    bibtex: "Profiling and tuning the performance of an {STM}-based concurrent program"
  projects:
    - "jvstm"
  authors:
    - me
    - jcachopo
  publication:
    type: workshop
    publisher: "ACM"
    nth:       ""
    title:
      full:    "Workshop on Transitioning to Multicore"
      short:   "TMC"
    location:  "Portland, OR, USA"
    date:      "October, 2011"
  downloads:
    pdf:    pina11tmc.pdf
    slides: pina11tmcslides.pdf
  abstract: "
      Over the last years, multicores have become accessible to the common
      developer.  Writing concurrent programs that are correct and that display good
      performance is hard.  Software Transactional Memory (STM) is a step in the
      direction of solving the first problem, but it does not provide tools for the
      programmer to understand and optimize his code's performance, thus leaving the
      second problem as an open issue.
      
      In this paper, we present a novel technique that informs the developer about
      which objects cause JVSTM transactions to conflict.  Then, we describe how we
      used that technique together with several JVSTM conflict reduction techniques to
      improve the performance of a transactional application.
      "
pina09msc:
  title:
    plain: "Atomic Dynamic Software Upgrades Using Software Transactional Memories"
  projects:
    - "dustm"
  authors:
    - me
  publication:
    type: mscthesis
    date: "November, 2009"
    school:
      plain:  "Instituto Superior Técnico, University of Lisbon"
      bibtex: "Instituto Superior T\\'{\\e}cnico, University of Lisbon"
    location: "Lisbon, Portugal"
  downloads:
    pdf:    pina09msc.pdf
  abstract: "
    The upgrade of a running program is often a disruptive operation that
    involves stopping and restarting the program's execution. Yet, software upgrades
    are unavoidable. Unfortunately, current solutions for dynamic upgrades are
    either incomplete or not practical. Systems that have high availability
    requirements implement upgrades through a combination of application-specific
    software and redundant hardware. However, such systems lack support to migrate
    the state of the running program to a state that is compatible with the program
    that the upgrade introduces. Typically, they migrate the persisted data only and
    the data migration process may impose a long pause on the application.
    
    To ensure the atomicity of the upgrade and data migration operations, but still
    allow them to execute in parallel with the rest of the system, thereby avoiding
    the restart of the system or long pauses, I introduce a conceptual model that
    defines the semantics of the upgrade system, and that may be implemented with
    any STM and programming language. Furthermore, the upgrade system that I propose
    and the data migration process can be integrated seamlessly with modern software
    engineering methodologies. I describe an implementation of the proposed upgrade
    system for the Java platform that uses JVSTM. I implemented a prototype of the
    upgrade system that is able to perform a significant number of different types
    of upgrades to a running Java application without stopping it, providing thus a
    proof of concept that the implementation of the upgrade system is feasible.
    "
pina09dsn:
  title:
    plain: "Towards a Pragmatic Atomic Dynamic Software Upgrade System"
  projects:
    - "dustm"
  authors:
    - me
  publication:
    type: workshop
    publisher: "IEEE"
    nth:       ""
    title:
      full:    "International Conference on Dependable Systems and Networks"
      short:   "DSN"
    location:  "Portland, OR, USA"
    location:  "Estoril, Portugal"
    date:      "June, 2009"
    notes:     "Student Forum"
  downloads:
    pdf:    pina09dsn.pdf
    slides: pina09dsnslides.pdf
  abstract: "
    The upgrade of a running program is often a disruptive operation that involves
    stopping and restarting the program's execution, becoming, thus, a serious
    problem for dependable systems. Yet, software upgrades are unavoidable.
    Unfortunately, current solutions for dynamic software upgrades are either
    incomplete or not practical. In this paper, I layout the foundations for a new
    dynamic software upgrade system that provides atomic upgrades and is designed to
    integrate seamlessly with the current software development practices. This new
    upgrade system leverages on a software transactional memory to ensure that all
    the requests of an upgraded system are processed in a consistent state of the
    program, either before or after the upgrade.
    "
