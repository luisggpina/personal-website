---
# Copyright 2017 LuÃ­s Pina
#
# This file is licensed under the Creative Commons Attribution-NoDerivatives 4.0
# International License. To view a copy of this license, visit
# http://creativecommons.org/licenses/by-nd/4.0/.
#
layout:     post
title:      Matching Linux Processes Through ptrace
tags:       ptrace, linux, varan
group:      "blog"
published:  true
highlight:	true
raphael:		true
comments: False
---

When I presented [my recent work on Varan](/projects/varan.html) recently, more than one person asked me
a variant of the following question:

> I've been using `ptrace` to force the exact same execution on two processes by
> ensuring both read the same data from their system calls.  Still, at some point,
> they start behaving differently (they diverge).  Why?

`ptrace` is a feature of the Linux kernel. [Quoting it's manual page](http://man7.org/linux/man-pages/man2/ptrace.2.html):

> The ptrace() system call provides a means by which one process (the "tracer")
> may observe and control the execution of another process (the "tracee"), and
> examine and change the tracee's memory and registers.  It is primarily used to
> implement breakpoint debugging and system call tracing.

When the tracee issues a system call, the tracer gets notified.  The tracer can
then change the parameters of the system call, or emulate it in any way.  For
instance, [`strace` uses ptrace to dump the sequence of system calls that a
process issues.](https://strace.io/)

So, we can launch the same program on two processes and use `ptrace` to match
their system calls:  Let one process issue a system call, wait for the other to
issue the same system call, and copy the results over.  Let me show you an
example.  The following function generates a random number by XOR-ing the
current time, and the process PID.

<pre><code class="C">
#define MORE_RANDOMNESS(X) ((X) = 0)

unsigned long random() {
    unsigned long ret;

    MORE_RANDOMNESS(ret);

    struct timeval t;
    gettimeofday(&t);
    ret ^= t.tv_sec ^ t.tv_usec;

    int pid = getpid();
    ret ^= (unsigned long)pid;

    return ret;
}
</code></pre>

This function issues two system calls:
[`gettimeofday`](http://man7.org/linux/man-pages/man2/gettimeofday.2.html) and
[`getpid`](http://man7.org/linux/man-pages/man2/getpid.2.html).  So, we can use
`ptrace` to launch two processes that run this function, *P1* and *P2*, add a
breakpoint before each system call, and copy the contents of variables `t`
and `pid` from *P1* to *P2*.  This results in the same result `ret`.  Right?

**Wrong**

In this post, I explain the main reasons why, according to my experience.

### Virtual System Calls

If you run the program that I show above under `strace` on an x86 machine, you
will notice the absence of system call `gettimeofday` from the trace.  Why?

System call `gettimeofday` in x86 is a [**virtual system
call**](http://man7.org/linux/man-pages/man2/getpid.2.html).  The Linux kernel
uses virtual system calls to accelerate common system calls that may execute
outside of the kernel.  The idea is that such "system calls" execute as a simple
function call, rather then an expensive context switch to kernel mode.  The
Linux kernel exposes a *virtual dynamic shared object* (*vDSO*) as an ELF file
mapped in every process and discoverable through the [auxiliary
vector](https://lwn.net/Articles/519085/).  Then, at runtime, libc scans the
auxiliary vector, finds the vDSO, and calls those functions instead of issuing
system calls.  Of course, this is completely transparent to the programmer using
those system calls.

The speed difference between virtual system calls and regular system calls is
quite noticeable.  This program issues 1.000.000 `gettimeofday` system calls, first
through libc (and thus using virtual system calls) and then manually through
hand-written assembly.  Here's the output on my machine:

<pre><code class="bash">
> gcc -O0 example.c
> time ./a.out   # system call
./a.out    0.04s user 0.08s system 97% cpu 0.123 total
> time ./a.out 0 #virtual system call
./a.out a  0.03s user 0.00s system 91% cpu 0.033 total
</code></pre>

That's a 3x difference!

Getting back to why `ptrace` fails, in this case there is no system call for
`ptrace` to intercept.  As a result, *P1* and *P2* get different values for `t`,
thus generating different values for `ret`.

### glibc `get_pid`

[glibc](https://www.gnu.org/software/libc/) is the GNU implementation of the C
standard library (libc), and the de-facto libc used in GNU/Linux.  Until
recently, glibc optimized system call `getpid` by caching the PID when
initializing (before the program's `main` function is called).  Then, function
[`getpid` simply reads the cached PID without issuing any system call](https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/getpid.c;h=112454932616872f4b98fefc54168b748c0b6853;hb=fdfc9260b61d3d72541f18104d24c7bcb0ce5ca2).

The program I show above uses `getpid` to generate the random number.  In our
scenario, if we wait until *P1* and *P2* reach their respective `main` function
to start matching their system calls through `ptrace`, we miss the caching of
the PID.  Therefore, each process gets a different value for variable `pid`.

At this point, we assume that there is a rogue system call `getpid` that we can
detect through `strace` on a program that does nothing: `int main() { return 0;
}`.  Unfortunately, that is not the system call that glibc uses to cache the
PID.  Instead, it uses the very unlikely process through the very unlikely
system call
[`set_tid_address`](http://man7.org/linux/man-pages/man2/set_tid_address.2.html),
so look out for that.

This approach of caching the PID has gathered some criticism.  [Linus Torvalds
himself uses colorful language to describe how he feels about this
optimization](http://yarchive.net/comp/linux/getpid_caching.html).  Recently,
[glibc removed this
optimization](https://sourceware.org/git/?p=glibc.git;a=commit;h=c579f48edba88380635ab98cb612030e3ed8691e),
which is not present since, and including, version 2.25 (released on
5/Feb/2017).

### `rdstc` Instruction


<pre><code class="C">
#define MORE_RANDOMNESS(X) ((X = rdtsc()))
</code></pre>

### Undefined Behavior

<pre><code class="C">
#define MORE_RANDOMNESS(X) ((X))
</code></pre>

### Shared Memory
